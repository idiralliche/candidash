/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * CandiDash API
 * Job application tracking system API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  BodyReplaceFileApiV1DocumentsDocumentIdReplaceFilePost,
  BodyUploadDocumentApiV1DocumentsUploadPost,
  Document,
  DocumentCreate,
  DocumentUpdate,
  GetDocumentsApiV1DocumentsGetParams,
  HTTPValidationError
} from '.././model';

import { customInstance } from '../../lib/api-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Retrieve a list of documents owned by the current user with pagination.

- **skip**: Number of records to skip (for pagination)
- **limit**: Maximum number of records to return (max 100)

Returns only documents belonging to the authenticated user.
 * @summary Get Documents
 */
export const getDocumentsApiV1DocumentsGet = (
    params?: GetDocumentsApiV1DocumentsGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Document[]>(
      {url: `/api/v1/documents/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetDocumentsApiV1DocumentsGetQueryKey = (params?: GetDocumentsApiV1DocumentsGetParams,) => {
    return [
    `/api/v1/documents/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetDocumentsApiV1DocumentsGetQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError = HTTPValidationError>(params?: GetDocumentsApiV1DocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentsApiV1DocumentsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>> = ({ signal }) => getDocumentsApiV1DocumentsGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentsApiV1DocumentsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>>
export type GetDocumentsApiV1DocumentsGetQueryError = HTTPValidationError


export function useGetDocumentsApiV1DocumentsGet<TData = Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError = HTTPValidationError>(
 params: undefined |  GetDocumentsApiV1DocumentsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>,
          TError,
          Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentsApiV1DocumentsGet<TData = Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError = HTTPValidationError>(
 params?: GetDocumentsApiV1DocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>,
          TError,
          Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentsApiV1DocumentsGet<TData = Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError = HTTPValidationError>(
 params?: GetDocumentsApiV1DocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Documents
 */

export function useGetDocumentsApiV1DocumentsGet<TData = Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError = HTTPValidationError>(
 params?: GetDocumentsApiV1DocumentsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentsApiV1DocumentsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentsApiV1DocumentsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new document record (for external links only).

**Request Body:**
- **name**: Document name (required, 1-255 chars)
- **type**: Document type - resume, cover_letter, portfolio, certificate, job_posting, other (required)
- **format**: Must be 'external' for external links (required)
- **path**: External URL - must be HTTP or HTTPS from public domains (required)
- **is_external**: Must be true (required)
- **description**: Free text description (optional, max 5000 chars)

**Automatic Validations (performed by Pydantic in DocumentCreate schema):**
- Path must be a valid HTTP/HTTPS URL when is_external=true
  (see @field_validator('path') in schemas/document.py ‚Üí validate_path_format())
- Format must be 'external' when is_external=true
  (see @field_validator('format') in schemas/document.py ‚Üí validate_format_consistency())
- URL must not point to localhost or private IP addresses (security)
  (see validators/document_validators.py ‚Üí validate_external_url())
- Dangerous protocols (javascript:, data:, file:) are blocked
  (see validators/document_validators.py ‚Üí validate_external_url())

**For File Uploads:**
Use POST /documents/upload instead of this endpoint.

**Returns:**
- **201**: Document created successfully

**Raises:**
- **422**: Validation error (invalid format, localhost URL, missing required fields, etc.)
- **401**: Unauthorized (not authenticated)

The document will be automatically assigned to the authenticated user.
 * @summary Create Document
 */
export const createDocumentApiV1DocumentsPost = (
    documentCreate: DocumentCreate,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Document>(
      {url: `/api/v1/documents/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: documentCreate, signal
    },
      options);
    }
  


export const getCreateDocumentApiV1DocumentsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDocumentApiV1DocumentsPost>>, TError,{data: DocumentCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createDocumentApiV1DocumentsPost>>, TError,{data: DocumentCreate}, TContext> => {

const mutationKey = ['createDocumentApiV1DocumentsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDocumentApiV1DocumentsPost>>, {data: DocumentCreate}> = (props) => {
          const {data} = props ?? {};

          return  createDocumentApiV1DocumentsPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDocumentApiV1DocumentsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createDocumentApiV1DocumentsPost>>>
    export type CreateDocumentApiV1DocumentsPostMutationBody = DocumentCreate
    export type CreateDocumentApiV1DocumentsPostMutationError = HTTPValidationError

    /**
 * @summary Create Document
 */
export const useCreateDocumentApiV1DocumentsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDocumentApiV1DocumentsPost>>, TError,{data: DocumentCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDocumentApiV1DocumentsPost>>,
        TError,
        {data: DocumentCreate},
        TContext
      > => {

      const mutationOptions = getCreateDocumentApiV1DocumentsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve a specific document by ID.

- **document_id**: The ID of the document to retrieve

Returns 404 if document doesn't exist or doesn't belong to the authenticated user.
 * @summary Get Document
 */
export const getDocumentApiV1DocumentsDocumentIdGet = (
    documentId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Document>(
      {url: `/api/v1/documents/${documentId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetDocumentApiV1DocumentsDocumentIdGetQueryKey = (documentId?: number,) => {
    return [
    `/api/v1/documents/${documentId}`
    ] as const;
    }

    
export const getGetDocumentApiV1DocumentsDocumentIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError = HTTPValidationError>(documentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetDocumentApiV1DocumentsDocumentIdGetQueryKey(documentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>> = ({ signal }) => getDocumentApiV1DocumentsDocumentIdGet(documentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(documentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetDocumentApiV1DocumentsDocumentIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>>
export type GetDocumentApiV1DocumentsDocumentIdGetQueryError = HTTPValidationError


export function useGetDocumentApiV1DocumentsDocumentIdGet<TData = Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError = HTTPValidationError>(
 documentId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentApiV1DocumentsDocumentIdGet<TData = Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError = HTTPValidationError>(
 documentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>,
          TError,
          Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetDocumentApiV1DocumentsDocumentIdGet<TData = Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError = HTTPValidationError>(
 documentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Document
 */

export function useGetDocumentApiV1DocumentsDocumentIdGet<TData = Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError = HTTPValidationError>(
 documentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getDocumentApiV1DocumentsDocumentIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetDocumentApiV1DocumentsDocumentIdGetQueryOptions(documentId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing document's metadata and/or storage location.

**Updatable Fields:**
- **name**: Document name
- **type**: Document type
- **description**: Description
- **path**: Storage path/URL (see storage migration below)
- **is_external**: Storage type (local or external)

**Storage Migration Scenarios:**

1. **Local ‚Üí External** (e.g., uploaded file ‚Üí Google Drive link):
   - Set `is_external: true` and `path: "https://drive.google.com/..."`
   - Local file will be automatically deleted
   - Format automatically set to 'external'

2. **External ‚Üí External** (e.g., Google Drive ‚Üí OneDrive):
   - Update `path: "https://onedrive.live.com/..."`
   - Keep `is_external: true` (or omit)

3. **External ‚Üí Local** (e.g., Drive link ‚Üí uploaded file):
   - NOT supported via PUT (would require file upload)
   - Use dedicated endpoint: POST /documents/{id}/replace-file

**Validations:**
- External URLs must be HTTPS from public domains (no localhost/private IPs)
- Path and is_external must be coherent (validated in validate_document_storage_update)
- Cannot make a document external without providing a valid URL

**Returns:**
- **200**: Document updated successfully

**Raises:**
- **400**: Invalid update (incoherent path/is_external, invalid URL, etc.)
- **401**: Unauthorized
- **404**: Document not found
 * @summary Update Document
 */
export const updateDocumentApiV1DocumentsDocumentIdPut = (
    documentId: number,
    documentUpdate: DocumentUpdate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Document>(
      {url: `/api/v1/documents/${documentId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: documentUpdate
    },
      options);
    }
  


export const getUpdateDocumentApiV1DocumentsDocumentIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDocumentApiV1DocumentsDocumentIdPut>>, TError,{documentId: number;data: DocumentUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateDocumentApiV1DocumentsDocumentIdPut>>, TError,{documentId: number;data: DocumentUpdate}, TContext> => {

const mutationKey = ['updateDocumentApiV1DocumentsDocumentIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDocumentApiV1DocumentsDocumentIdPut>>, {documentId: number;data: DocumentUpdate}> = (props) => {
          const {documentId,data} = props ?? {};

          return  updateDocumentApiV1DocumentsDocumentIdPut(documentId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDocumentApiV1DocumentsDocumentIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateDocumentApiV1DocumentsDocumentIdPut>>>
    export type UpdateDocumentApiV1DocumentsDocumentIdPutMutationBody = DocumentUpdate
    export type UpdateDocumentApiV1DocumentsDocumentIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Document
 */
export const useUpdateDocumentApiV1DocumentsDocumentIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDocumentApiV1DocumentsDocumentIdPut>>, TError,{documentId: number;data: DocumentUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDocumentApiV1DocumentsDocumentIdPut>>,
        TError,
        {documentId: number;data: DocumentUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateDocumentApiV1DocumentsDocumentIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete a document permanently.

**Parameters:**
- **document_id**: The ID of the document to delete (required)

**Behavior:**
- **Local files** (is_external=false): Deletes both database record AND physical file
- **External links** (is_external=true): Deletes only database record (URL not affected)

**Note:** Deletion is permanent and cannot be undone.
If the physical file is already missing (local files), the database record is still deleted.

**Returns:**
- **204**: Document deleted successfully (no content)

**Raises:**
- **401**: Unauthorized (not authenticated)
- **404**: Document not found or doesn't belong to user

Only documents belonging to the authenticated user can be deleted.
 * @summary Delete Document
 */
export const deleteDocumentApiV1DocumentsDocumentIdDelete = (
    documentId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/documents/${documentId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteDocumentApiV1DocumentsDocumentIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentApiV1DocumentsDocumentIdDelete>>, TError,{documentId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentApiV1DocumentsDocumentIdDelete>>, TError,{documentId: number}, TContext> => {

const mutationKey = ['deleteDocumentApiV1DocumentsDocumentIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDocumentApiV1DocumentsDocumentIdDelete>>, {documentId: number}> = (props) => {
          const {documentId} = props ?? {};

          return  deleteDocumentApiV1DocumentsDocumentIdDelete(documentId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDocumentApiV1DocumentsDocumentIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDocumentApiV1DocumentsDocumentIdDelete>>>
    
    export type DeleteDocumentApiV1DocumentsDocumentIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Document
 */
export const useDeleteDocumentApiV1DocumentsDocumentIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDocumentApiV1DocumentsDocumentIdDelete>>, TError,{documentId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDocumentApiV1DocumentsDocumentIdDelete>>,
        TError,
        {documentId: number},
        TContext
      > => {

      const mutationOptions = getDeleteDocumentApiV1DocumentsDocumentIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Upload a document file (local storage).

**Form Fields:**
- **file**: File to upload (multipart/form-data, required)
- **name**: Document name (required, 1-255 chars)
- **type**: Document type - resume, cover_letter, portfolio, certificate, job_posting, other (required)
- **description**: Optional description (max 5000 chars)

**Supported File Formats:**
- Documents: PDF, DOC, DOCX, RTF, TXT, MD, ODT
- Presentations: PPT, PPTX, ODP
- Spreadsheets: XLS, XLSX, ODS, CSV, TSV
- Images: JPG, PNG, GIF, WEBP
- Data: JSON

**Automatic Validations (performed in process_uploaded_file helper):**
- File size must not exceed 10 MB
- MIME type validation using file content analysis (python-magic)
- File extension must be in allowed list
- Filename sanitization (prevents path traversal attacks)

**Quota Check:**
- Max 500 documents per user (check_user_quota)

**Storage:**
Files are stored as: {DOCUMENTS_PATH}/{user_id}/{uuid}.{extension}

**Returns:**
- **201**: Document uploaded and created successfully

**Raises:**
- **400**: Invalid file type or extension
- **401**: Unauthorized (not authenticated)
- **413**: File too large or quota exceeded
- **422**: Validation error (missing fields, etc.)

The document will be automatically assigned to the authenticated user.
 * @summary Upload Document
 */
export const uploadDocumentApiV1DocumentsUploadPost = (
    bodyUploadDocumentApiV1DocumentsUploadPost: BodyUploadDocumentApiV1DocumentsUploadPost,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyUploadDocumentApiV1DocumentsUploadPost.file)
formData.append(`name`, bodyUploadDocumentApiV1DocumentsUploadPost.name)
formData.append(`type`, bodyUploadDocumentApiV1DocumentsUploadPost.type)
if(bodyUploadDocumentApiV1DocumentsUploadPost.description !== undefined) {
 formData.append(`description`, bodyUploadDocumentApiV1DocumentsUploadPost.description)
 }

      return customInstance<Document>(
      {url: `/api/v1/documents/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getUploadDocumentApiV1DocumentsUploadPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadDocumentApiV1DocumentsUploadPost>>, TError,{data: BodyUploadDocumentApiV1DocumentsUploadPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof uploadDocumentApiV1DocumentsUploadPost>>, TError,{data: BodyUploadDocumentApiV1DocumentsUploadPost}, TContext> => {

const mutationKey = ['uploadDocumentApiV1DocumentsUploadPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof uploadDocumentApiV1DocumentsUploadPost>>, {data: BodyUploadDocumentApiV1DocumentsUploadPost}> = (props) => {
          const {data} = props ?? {};

          return  uploadDocumentApiV1DocumentsUploadPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UploadDocumentApiV1DocumentsUploadPostMutationResult = NonNullable<Awaited<ReturnType<typeof uploadDocumentApiV1DocumentsUploadPost>>>
    export type UploadDocumentApiV1DocumentsUploadPostMutationBody = BodyUploadDocumentApiV1DocumentsUploadPost
    export type UploadDocumentApiV1DocumentsUploadPostMutationError = HTTPValidationError

    /**
 * @summary Upload Document
 */
export const useUploadDocumentApiV1DocumentsUploadPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof uploadDocumentApiV1DocumentsUploadPost>>, TError,{data: BodyUploadDocumentApiV1DocumentsUploadPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof uploadDocumentApiV1DocumentsUploadPost>>,
        TError,
        {data: BodyUploadDocumentApiV1DocumentsUploadPost},
        TContext
      > => {

      const mutationOptions = getUploadDocumentApiV1DocumentsUploadPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Download a document or redirect to external link.

**Parameters:**
- **document_id**: The ID of the document to download (required)

**Behavior:**
- **Local files** (is_external=false): Returns file with appropriate Content-Type
  * Browser will display if possible (PDF, images)
  * User can download via browser's download button
  * Content-Disposition: inline with original filename

- **External links** (is_external=true): Redirects to external URL (307 redirect)

**Returns:**
- **200**: File streamed successfully (local files)
- **307**: Temporary redirect to external URL (external links)

**Raises:**
- **401**: Unauthorized (not authenticated)
- **404**: Document not found, doesn't belong to user, or file missing on storage

Only documents belonging to the authenticated user can be accessed.
 * @summary Download Document
 */
export const downloadDocumentApiV1DocumentsDocumentIdDownloadGet = (
    documentId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<unknown>(
      {url: `/api/v1/documents/${documentId}/download`, method: 'GET', signal
    },
      options);
    }
  



export const getDownloadDocumentApiV1DocumentsDocumentIdDownloadGetQueryKey = (documentId?: number,) => {
    return [
    `/api/v1/documents/${documentId}/download`
    ] as const;
    }

    
export const getDownloadDocumentApiV1DocumentsDocumentIdDownloadGetQueryOptions = <TData = Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError = HTTPValidationError>(documentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getDownloadDocumentApiV1DocumentsDocumentIdDownloadGetQueryKey(documentId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>> = ({ signal }) => downloadDocumentApiV1DocumentsDocumentIdDownloadGet(documentId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(documentId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type DownloadDocumentApiV1DocumentsDocumentIdDownloadGetQueryResult = NonNullable<Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>>
export type DownloadDocumentApiV1DocumentsDocumentIdDownloadGetQueryError = HTTPValidationError


export function useDownloadDocumentApiV1DocumentsDocumentIdDownloadGet<TData = Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError = HTTPValidationError>(
 documentId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>,
          TError,
          Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadDocumentApiV1DocumentsDocumentIdDownloadGet<TData = Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError = HTTPValidationError>(
 documentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>,
          TError,
          Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useDownloadDocumentApiV1DocumentsDocumentIdDownloadGet<TData = Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError = HTTPValidationError>(
 documentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Download Document
 */

export function useDownloadDocumentApiV1DocumentsDocumentIdDownloadGet<TData = Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError = HTTPValidationError>(
 documentId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof downloadDocumentApiV1DocumentsDocumentIdDownloadGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDownloadDocumentApiV1DocumentsDocumentIdDownloadGetQueryOptions(documentId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Replace an external document with an uploaded file (external ‚Üí local conversion).

**Use Case:**
User has an external link (Google Drive, OneDrive, etc.) and wants to store
the file directly on CandiDash instead, while keeping the same document ID
and metadata (name, type, description).

**Process:**
1. User downloads file from external source manually
2. User uploads file via this endpoint
3. Document keeps same ID, name, type, description
4. Only path, format, is_external change

**Validations (performed in process_uploaded_file helper):**
- File size must not exceed 10 MB
- MIME type validation with python-magic
- File extension must be allowed
- Filename sanitization

**Quota Check:**
- Max 500 documents per user (check_user_quota)
- Document must currently be external (is_external=true)

**Returns:**
- **200**: File uploaded and document converted successfully

**Raises:**
- **400**: Document is already local, or file validation failed
- **401**: Unauthorized
- **404**: Document not found
- **413**: File too large or quota exceeded
 * @summary Replace File
 */
export const replaceFileApiV1DocumentsDocumentIdReplaceFilePost = (
    documentId: number,
    bodyReplaceFileApiV1DocumentsDocumentIdReplaceFilePost: BodyReplaceFileApiV1DocumentsDocumentIdReplaceFilePost,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append(`file`, bodyReplaceFileApiV1DocumentsDocumentIdReplaceFilePost.file)

      return customInstance<Document>(
      {url: `/api/v1/documents/${documentId}/replace-file`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      options);
    }
  


export const getReplaceFileApiV1DocumentsDocumentIdReplaceFilePostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replaceFileApiV1DocumentsDocumentIdReplaceFilePost>>, TError,{documentId: number;data: BodyReplaceFileApiV1DocumentsDocumentIdReplaceFilePost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof replaceFileApiV1DocumentsDocumentIdReplaceFilePost>>, TError,{documentId: number;data: BodyReplaceFileApiV1DocumentsDocumentIdReplaceFilePost}, TContext> => {

const mutationKey = ['replaceFileApiV1DocumentsDocumentIdReplaceFilePost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replaceFileApiV1DocumentsDocumentIdReplaceFilePost>>, {documentId: number;data: BodyReplaceFileApiV1DocumentsDocumentIdReplaceFilePost}> = (props) => {
          const {documentId,data} = props ?? {};

          return  replaceFileApiV1DocumentsDocumentIdReplaceFilePost(documentId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplaceFileApiV1DocumentsDocumentIdReplaceFilePostMutationResult = NonNullable<Awaited<ReturnType<typeof replaceFileApiV1DocumentsDocumentIdReplaceFilePost>>>
    export type ReplaceFileApiV1DocumentsDocumentIdReplaceFilePostMutationBody = BodyReplaceFileApiV1DocumentsDocumentIdReplaceFilePost
    export type ReplaceFileApiV1DocumentsDocumentIdReplaceFilePostMutationError = HTTPValidationError

    /**
 * @summary Replace File
 */
export const useReplaceFileApiV1DocumentsDocumentIdReplaceFilePost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replaceFileApiV1DocumentsDocumentIdReplaceFilePost>>, TError,{documentId: number;data: BodyReplaceFileApiV1DocumentsDocumentIdReplaceFilePost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replaceFileApiV1DocumentsDocumentIdReplaceFilePost>>,
        TError,
        {documentId: number;data: BodyReplaceFileApiV1DocumentsDocumentIdReplaceFilePost},
        TContext
      > => {

      const mutationOptions = getReplaceFileApiV1DocumentsDocumentIdReplaceFilePostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    