/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * CandiDash API
 * Job application tracking system API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Action,
  ActionCreate,
  ActionUpdate,
  GetActionsApiV1ActionsGetParams,
  HTTPValidationError
} from '.././model';

import { customInstance } from '../../lib/api-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Retrieve a list of actions owned by the current user with pagination and optional filtering.

- **skip**: Number of records to skip (for pagination)
- **limit**: Maximum number of records to return (max 100)
- **application_id**: Optional filter by application ID
- **completed**: Filter by completion (true=completed_date NOT NULL, false=NULL)
 * @summary Get Actions
 */
export const getActionsApiV1ActionsGet = (
    params?: GetActionsApiV1ActionsGetParams,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Action[]>(
      {url: `/api/v1/actions/`, method: 'GET',
        params, signal
    },
      options);
    }
  



export const getGetActionsApiV1ActionsGetQueryKey = (params?: GetActionsApiV1ActionsGetParams,) => {
    return [
    `/api/v1/actions/`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getGetActionsApiV1ActionsGetQueryOptions = <TData = Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError = HTTPValidationError>(params?: GetActionsApiV1ActionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionsApiV1ActionsGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>> = ({ signal }) => getActionsApiV1ActionsGet(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActionsApiV1ActionsGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>>
export type GetActionsApiV1ActionsGetQueryError = HTTPValidationError


export function useGetActionsApiV1ActionsGet<TData = Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError = HTTPValidationError>(
 params: undefined |  GetActionsApiV1ActionsGetParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>,
          TError,
          Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionsApiV1ActionsGet<TData = Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError = HTTPValidationError>(
 params?: GetActionsApiV1ActionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>,
          TError,
          Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionsApiV1ActionsGet<TData = Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError = HTTPValidationError>(
 params?: GetActionsApiV1ActionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Actions
 */

export function useGetActionsApiV1ActionsGet<TData = Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError = HTTPValidationError>(
 params?: GetActionsApiV1ActionsGetParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionsApiV1ActionsGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActionsApiV1ActionsGetQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Create a new action.

- **application_id**: ID of the application (required)
- **type**: Type of action (required)
- **scheduled_event_id**: ID of associated event (optional)
 * @summary Create Action
 */
export const createActionApiV1ActionsPost = (
    actionCreate: ActionCreate,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Action>(
      {url: `/api/v1/actions/`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: actionCreate, signal
    },
      options);
    }
  


export const getCreateActionApiV1ActionsPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createActionApiV1ActionsPost>>, TError,{data: ActionCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof createActionApiV1ActionsPost>>, TError,{data: ActionCreate}, TContext> => {

const mutationKey = ['createActionApiV1ActionsPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createActionApiV1ActionsPost>>, {data: ActionCreate}> = (props) => {
          const {data} = props ?? {};

          return  createActionApiV1ActionsPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateActionApiV1ActionsPostMutationResult = NonNullable<Awaited<ReturnType<typeof createActionApiV1ActionsPost>>>
    export type CreateActionApiV1ActionsPostMutationBody = ActionCreate
    export type CreateActionApiV1ActionsPostMutationError = HTTPValidationError

    /**
 * @summary Create Action
 */
export const useCreateActionApiV1ActionsPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createActionApiV1ActionsPost>>, TError,{data: ActionCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createActionApiV1ActionsPost>>,
        TError,
        {data: ActionCreate},
        TContext
      > => {

      const mutationOptions = getCreateActionApiV1ActionsPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Retrieve a specific action by ID.

- **action_id**: The ID of the action to retrieve

Returns 404 if action doesn't exist or doesn't belong to the authenticated user.
 * @summary Get Action
 */
export const getActionApiV1ActionsActionIdGet = (
    actionId: number,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Action>(
      {url: `/api/v1/actions/${actionId}`, method: 'GET', signal
    },
      options);
    }
  



export const getGetActionApiV1ActionsActionIdGetQueryKey = (actionId?: number,) => {
    return [
    `/api/v1/actions/${actionId}`
    ] as const;
    }

    
export const getGetActionApiV1ActionsActionIdGetQueryOptions = <TData = Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError = HTTPValidationError>(actionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetActionApiV1ActionsActionIdGetQueryKey(actionId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>> = ({ signal }) => getActionApiV1ActionsActionIdGet(actionId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(actionId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetActionApiV1ActionsActionIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>>
export type GetActionApiV1ActionsActionIdGetQueryError = HTTPValidationError


export function useGetActionApiV1ActionsActionIdGet<TData = Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError = HTTPValidationError>(
 actionId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>,
          TError,
          Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionApiV1ActionsActionIdGet<TData = Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError = HTTPValidationError>(
 actionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>,
          TError,
          Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetActionApiV1ActionsActionIdGet<TData = Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError = HTTPValidationError>(
 actionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Action
 */

export function useGetActionApiV1ActionsActionIdGet<TData = Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError = HTTPValidationError>(
 actionId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getActionApiV1ActionsActionIdGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetActionApiV1ActionsActionIdGetQueryOptions(actionId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Update an existing action.

- **action_id**: The ID of the action to update
- All fields are optional

Returns 404 if action doesn't exist or doesn't belong to the authenticated user.
 * @summary Update Action
 */
export const updateActionApiV1ActionsActionIdPut = (
    actionId: number,
    actionUpdate: ActionUpdate,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<Action>(
      {url: `/api/v1/actions/${actionId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: actionUpdate
    },
      options);
    }
  


export const getUpdateActionApiV1ActionsActionIdPutMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateActionApiV1ActionsActionIdPut>>, TError,{actionId: number;data: ActionUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof updateActionApiV1ActionsActionIdPut>>, TError,{actionId: number;data: ActionUpdate}, TContext> => {

const mutationKey = ['updateActionApiV1ActionsActionIdPut'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateActionApiV1ActionsActionIdPut>>, {actionId: number;data: ActionUpdate}> = (props) => {
          const {actionId,data} = props ?? {};

          return  updateActionApiV1ActionsActionIdPut(actionId,data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateActionApiV1ActionsActionIdPutMutationResult = NonNullable<Awaited<ReturnType<typeof updateActionApiV1ActionsActionIdPut>>>
    export type UpdateActionApiV1ActionsActionIdPutMutationBody = ActionUpdate
    export type UpdateActionApiV1ActionsActionIdPutMutationError = HTTPValidationError

    /**
 * @summary Update Action
 */
export const useUpdateActionApiV1ActionsActionIdPut = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateActionApiV1ActionsActionIdPut>>, TError,{actionId: number;data: ActionUpdate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateActionApiV1ActionsActionIdPut>>,
        TError,
        {actionId: number;data: ActionUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateActionApiV1ActionsActionIdPutMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Delete an action.

- **action_id**: The ID of the action to delete

Returns 404 if action doesn't exist or doesn't belong to the authenticated user.
 * @summary Delete Action
 */
export const deleteActionApiV1ActionsActionIdDelete = (
    actionId: number,
 options?: SecondParameter<typeof customInstance>,) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/actions/${actionId}`, method: 'DELETE'
    },
      options);
    }
  


export const getDeleteActionApiV1ActionsActionIdDeleteMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteActionApiV1ActionsActionIdDelete>>, TError,{actionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof deleteActionApiV1ActionsActionIdDelete>>, TError,{actionId: number}, TContext> => {

const mutationKey = ['deleteActionApiV1ActionsActionIdDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteActionApiV1ActionsActionIdDelete>>, {actionId: number}> = (props) => {
          const {actionId} = props ?? {};

          return  deleteActionApiV1ActionsActionIdDelete(actionId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteActionApiV1ActionsActionIdDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof deleteActionApiV1ActionsActionIdDelete>>>
    
    export type DeleteActionApiV1ActionsActionIdDeleteMutationError = HTTPValidationError

    /**
 * @summary Delete Action
 */
export const useDeleteActionApiV1ActionsActionIdDelete = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteActionApiV1ActionsActionIdDelete>>, TError,{actionId: number}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteActionApiV1ActionsActionIdDelete>>,
        TError,
        {actionId: number},
        TContext
      > => {

      const mutationOptions = getDeleteActionApiV1ActionsActionIdDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    