/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * CandiDash API
 * Job application tracking system API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  BodyLoginApiV1AuthLoginPost,
  HTTPValidationError,
  Token,
  User,
  UserCreate
} from '.././model';

import { customInstance } from '../../lib/api-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Register a new user.

- **email**: User email (must be unique)
- **first_name**: User first name (optional)
- **last_name**: User last name (optional)
- **password**: Password (minimum 8 characters)
- **confirm_password**: Password confirmation (must match)
 * @summary Register
 */
export const registerApiV1AuthRegisterPost = (
    userCreate: UserCreate,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<User>(
      {url: `/api/v1/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      options);
    }
  


export const getRegisterApiV1AuthRegisterPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['registerApiV1AuthRegisterPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerApiV1AuthRegisterPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterApiV1AuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>>
    export type RegisterApiV1AuthRegisterPostMutationBody = UserCreate
    export type RegisterApiV1AuthRegisterPostMutationError = HTTPValidationError

    /**
 * @summary Register
 */
export const useRegisterApiV1AuthRegisterPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getRegisterApiV1AuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Login with email and password to get JWT access token.

OAuth2 compatible - use 'username' field for email.

- **username**: User email address
- **password**: User password

Returns JWT access token for authenticated requests.
 * @summary Login
 */
export const loginApiV1AuthLoginPost = (
    bodyLoginApiV1AuthLoginPost: BodyLoginApiV1AuthLoginPost,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formUrlEncoded = new URLSearchParams();
if(bodyLoginApiV1AuthLoginPost.grant_type !== undefined && bodyLoginApiV1AuthLoginPost.grant_type !== null) {
 formUrlEncoded.append(`grant_type`, bodyLoginApiV1AuthLoginPost.grant_type)
 }
formUrlEncoded.append(`username`, bodyLoginApiV1AuthLoginPost.username)
formUrlEncoded.append(`password`, bodyLoginApiV1AuthLoginPost.password)
if(bodyLoginApiV1AuthLoginPost.scope !== undefined) {
 formUrlEncoded.append(`scope`, bodyLoginApiV1AuthLoginPost.scope)
 }
if(bodyLoginApiV1AuthLoginPost.client_id !== undefined && bodyLoginApiV1AuthLoginPost.client_id !== null) {
 formUrlEncoded.append(`client_id`, bodyLoginApiV1AuthLoginPost.client_id)
 }
if(bodyLoginApiV1AuthLoginPost.client_secret !== undefined && bodyLoginApiV1AuthLoginPost.client_secret !== null) {
 formUrlEncoded.append(`client_secret`, bodyLoginApiV1AuthLoginPost.client_secret)
 }

      return customInstance<Token>(
      {url: `/api/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      options);
    }
  


export const getLoginApiV1AuthLoginPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: BodyLoginApiV1AuthLoginPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: BodyLoginApiV1AuthLoginPost}, TContext> => {

const mutationKey = ['loginApiV1AuthLoginPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, {data: BodyLoginApiV1AuthLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  loginApiV1AuthLoginPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginApiV1AuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>>
    export type LoginApiV1AuthLoginPostMutationBody = BodyLoginApiV1AuthLoginPost
    export type LoginApiV1AuthLoginPostMutationError = HTTPValidationError

    /**
 * @summary Login
 */
export const useLoginApiV1AuthLoginPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: BodyLoginApiV1AuthLoginPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
        TError,
        {data: BodyLoginApiV1AuthLoginPost},
        TContext
      > => {

      const mutationOptions = getLoginApiV1AuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    