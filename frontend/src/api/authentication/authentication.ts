/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * CandiDash API
 * Job application tracking system API
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  BodyLoginApiV1AuthLoginPost,
  HTTPValidationError,
  Token,
  User,
  UserCreate
} from '.././model';

import { customInstance } from '../../lib/api-client';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Register a new user.

- **email**: User email (must be unique)
- **first_name**: User first name (optional)
- **last_name**: User last name (optional)
- **password**: Password (minimum 8 characters)
- **confirm_password**: Password confirmation (must match)
 * @summary Register
 */
export const registerApiV1AuthRegisterPost = (
    userCreate: UserCreate,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<User>(
      {url: `/api/v1/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      options);
    }
  


export const getRegisterApiV1AuthRegisterPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['registerApiV1AuthRegisterPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerApiV1AuthRegisterPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterApiV1AuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>>
    export type RegisterApiV1AuthRegisterPostMutationBody = UserCreate
    export type RegisterApiV1AuthRegisterPostMutationError = HTTPValidationError

    /**
 * @summary Register
 */
export const useRegisterApiV1AuthRegisterPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>, TError,{data: UserCreate}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerApiV1AuthRegisterPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getRegisterApiV1AuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Login with email and password.

Returns Access Token in body and sets Refresh Token in HttpOnly cookie.
 * @summary Login
 */
export const loginApiV1AuthLoginPost = (
    bodyLoginApiV1AuthLoginPost: BodyLoginApiV1AuthLoginPost,
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      const formUrlEncoded = new URLSearchParams();
if(bodyLoginApiV1AuthLoginPost.grant_type !== undefined && bodyLoginApiV1AuthLoginPost.grant_type !== null) {
 formUrlEncoded.append(`grant_type`, bodyLoginApiV1AuthLoginPost.grant_type)
 }
formUrlEncoded.append(`username`, bodyLoginApiV1AuthLoginPost.username)
formUrlEncoded.append(`password`, bodyLoginApiV1AuthLoginPost.password)
if(bodyLoginApiV1AuthLoginPost.scope !== undefined) {
 formUrlEncoded.append(`scope`, bodyLoginApiV1AuthLoginPost.scope)
 }
if(bodyLoginApiV1AuthLoginPost.client_id !== undefined && bodyLoginApiV1AuthLoginPost.client_id !== null) {
 formUrlEncoded.append(`client_id`, bodyLoginApiV1AuthLoginPost.client_id)
 }
if(bodyLoginApiV1AuthLoginPost.client_secret !== undefined && bodyLoginApiV1AuthLoginPost.client_secret !== null) {
 formUrlEncoded.append(`client_secret`, bodyLoginApiV1AuthLoginPost.client_secret)
 }

      return customInstance<Token>(
      {url: `/api/v1/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      options);
    }
  


export const getLoginApiV1AuthLoginPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: BodyLoginApiV1AuthLoginPost}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: BodyLoginApiV1AuthLoginPost}, TContext> => {

const mutationKey = ['loginApiV1AuthLoginPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, {data: BodyLoginApiV1AuthLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  loginApiV1AuthLoginPost(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginApiV1AuthLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>>
    export type LoginApiV1AuthLoginPostMutationBody = BodyLoginApiV1AuthLoginPost
    export type LoginApiV1AuthLoginPostMutationError = HTTPValidationError

    /**
 * @summary Login
 */
export const useLoginApiV1AuthLoginPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>, TError,{data: BodyLoginApiV1AuthLoginPost}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginApiV1AuthLoginPost>>,
        TError,
        {data: BodyLoginApiV1AuthLoginPost},
        TContext
      > => {

      const mutationOptions = getLoginApiV1AuthLoginPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Refresh access token using the refresh token from cookie.

Performs token rotation: invalidates old refresh token and issues a new one.
 * @summary Refresh Token
 */
export const refreshTokenApiV1AuthRefreshPost = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<Token>(
      {url: `/api/v1/auth/refresh`, method: 'POST', signal
    },
      options);
    }
  


export const getRefreshTokenApiV1AuthRefreshPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshTokenApiV1AuthRefreshPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof refreshTokenApiV1AuthRefreshPost>>, TError,void, TContext> => {

const mutationKey = ['refreshTokenApiV1AuthRefreshPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof refreshTokenApiV1AuthRefreshPost>>, void> = () => {
          

          return  refreshTokenApiV1AuthRefreshPost(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RefreshTokenApiV1AuthRefreshPostMutationResult = NonNullable<Awaited<ReturnType<typeof refreshTokenApiV1AuthRefreshPost>>>
    
    export type RefreshTokenApiV1AuthRefreshPostMutationError = HTTPValidationError

    /**
 * @summary Refresh Token
 */
export const useRefreshTokenApiV1AuthRefreshPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof refreshTokenApiV1AuthRefreshPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof refreshTokenApiV1AuthRefreshPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getRefreshTokenApiV1AuthRefreshPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Logout user by blacklisting the refresh token and clearing the cookie.
 * @summary Logout
 */
export const logoutApiV1AuthLogoutPost = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/auth/logout`, method: 'POST', signal
    },
      options);
    }
  


export const getLogoutApiV1AuthLogoutPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>, TError,void, TContext> => {

const mutationKey = ['logoutApiV1AuthLogoutPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>, void> = () => {
          

          return  logoutApiV1AuthLogoutPost(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutApiV1AuthLogoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>>
    
    export type LogoutApiV1AuthLogoutPostMutationError = HTTPValidationError

    /**
 * @summary Logout
 */
export const useLogoutApiV1AuthLogoutPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logoutApiV1AuthLogoutPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutApiV1AuthLogoutPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Logout from all devices.

Requires valid Access Token. Revokes all refresh tokens for the current user.
 * @summary Logout All
 */
export const logoutAllApiV1AuthLogoutAllPost = (
    
 options?: SecondParameter<typeof customInstance>,signal?: AbortSignal
) => {
      
      
      return customInstance<void>(
      {url: `/api/v1/auth/logout-all`, method: 'POST', signal
    },
      options);
    }
  


export const getLogoutAllApiV1AuthLogoutAllPostMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutAllApiV1AuthLogoutAllPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof logoutAllApiV1AuthLogoutAllPost>>, TError,void, TContext> => {

const mutationKey = ['logoutAllApiV1AuthLogoutAllPost'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof logoutAllApiV1AuthLogoutAllPost>>, void> = () => {
          

          return  logoutAllApiV1AuthLogoutAllPost(requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LogoutAllApiV1AuthLogoutAllPostMutationResult = NonNullable<Awaited<ReturnType<typeof logoutAllApiV1AuthLogoutAllPost>>>
    
    export type LogoutAllApiV1AuthLogoutAllPostMutationError = unknown

    /**
 * @summary Logout All
 */
export const useLogoutAllApiV1AuthLogoutAllPost = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof logoutAllApiV1AuthLogoutAllPost>>, TError,void, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof logoutAllApiV1AuthLogoutAllPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getLogoutAllApiV1AuthLogoutAllPostMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    